layout (local_size_x = X_SIZE, local_size_y = Y_SIZE, local_size_z = 1) in;

uniform float k[KENNEL_SIZE];
uniform int kennel_index;
uniform int padding;
uniform int padding_type;
uniform int strides[2];
uniform int kennel_shape[3];  // w,h,c
uniform int input_shape[3];   // w,h,c
uniform int output_shape[3];  // w,h,c
layout(binding = 0, rgba32f) readonly uniform image2D input_image1;
layout(binding = 1, rgba32f) readonly uniform image2D input_image2; //input_image2 == output_image
layout(binding = 2, rgba32f) writeonly uniform image2D output_image;

bool isZero(ivec2 index);
float convolute(ivec2 pos);
ivec2[KENNEL_AREA] getInputIndexInFeatureMap(ivec2 pos);
float performConvolute(int num, ivec2 [KENNEL_AREA] input_data_index);
ivec3 getRealStoreIndex(ivec2 pos);
ivec2 getFeatureMapIndexInTexture(int num, int width);

// test
//void main(void) {
//    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
//    vec4 data_origin = imageLoad(input_image2, pos.xy);
//    data_origin.r = data_origin.r + float(strides[0]*pos.x);
//    data_origin.g = data_origin.g + float(strides[1]*pos.y);
//    imageStore(output_image, pos.xy, data_origin);
//}

void main(void)
{
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec3 real_pos = getRealStoreIndex(pos);
    vec4 data_origin = imageLoad(input_image2, real_pos.xy);
    float convolute_output = convolute(pos);
    data_origin[real_pos.z] = convolute_output;
    imageStore(output_image, real_pos.xy, data_origin);
}

ivec2 getFeatureMapIndexInTexture(int num, int width) {
    int xMaxCount = 1024 / width;   // 1024 是设置的存储纹理边长
    int x =0;
    int y =0;
    if (num < xMaxCount) {
        x = num;
    } else {
        x = num % xMaxCount;
        y = num / xMaxCount;
    }
    return ivec2(x,y);
}

// 获得实际存储位置 x,y表示在特征图上的坐标，z表示是第几张特征图
ivec3 getRealStoreIndex(ivec2 pos) {
    int count = kennel_index/4;
    int remain = kennel_index % 4;
    ivec2 relative_pos = pos.xy;
    ivec2 feature_map_index_in_texture = getFeatureMapIndexInTexture(count, output_shape[0]);
    ivec2 index_in_texture = relative_pos + ivec2(feature_map_index_in_texture[0]*output_shape[0], feature_map_index_in_texture[1]*output_shape[1]);
    return ivec3(index_in_texture, remain);
}

// 判断是否处于padding区域
bool isZero(ivec2 index) {
    ivec2 index = ivec2(index.x%input_shape[0], index.y%input_shape[1]);
    if (index.x < 0 || index.x >= input_shape[1]) {
        return true;
    } else if (index.y < 0 || index.y >= input_shape[0]) {
        return true;
    }
    return false;
}

// 获得本次卷积 在特征图上的坐标
ivec2[KENNEL_AREA] getInputIndexInFeatureMap(ivec2 pos) {
    ivec2 input_data_index[KENNEL_AREA];
    for (int y=0; y < kennel_shape[1]; y++){
        for (int x=0;x < kennel_shape[0]; x++){
            input_data_index[y*kennel_shape[0] + x] = ivec2(-padding,-padding) + ivec2(x,y) + ivec2(strides[0]*pos.x, strides[1]*pos.y);
        }
    }
    return input_data_index;
}

// 在一组特征图上继续卷积运算
float performConvolute(int num, ivec2[KENNEL_AREA] input_data_index) {
    ivec2 feature_map_index_in_texture = getFeatureMapIndexInTexture(num, input_shape[0]);

    float output_value = 0.0;
    for (int i = 0; i < KENNEL_AREA;i++){
        ivec2 index = input_data_index[i];
        if (!isZero(index)) {
            ivec2 index_in_texture = index + ivec2(feature_map_index_in_texture[0]*input_shape[0],feature_map_index_in_texture[1]*input_shape[1]);
            vec4 data = imageLoad(input_image1, index_in_texture);
            for (int ii = 0;ii < 4; ii++) {
                int kennel_value_index = (num * 4 + ii) * KENNEL_AREA + i;
                if (kennel_value_index < KENNEL_SIZE) {
                    output_value += data[ii] * k[kennel_value_index];
                }
            }
        }
    }
    return output_value;
}

// 获得本次卷积 在纹理上的坐标
float convolute(ivec2 pos) {
    ivec2 input_data_index[KENNEL_AREA] = getInputIndexInFeatureMap(pos);
    float output_value = 0.0;

    int count = kennel_shape[2]/4;
    int remain = kennel_shape[2] % 4;
    if (remain != 0) {
        count = count + 1;
    }

    for (int i=0; i < count; i++) {
        output_value += performConvolute(i, input_data_index);
    }
    return output_value;
}