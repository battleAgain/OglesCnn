layout (local_size_x = X_SIZE, local_size_y = Y_SIZE, local_size_z = Z_SIZE) in;

uniform int params[7];  // input_shape[3] output_shape[3] active_type
layout(binding = 0, rgba32f) readonly uniform image2D input_image;
layout(binding = 1, rgba32f) writeonly uniform image2D output_image;

layout(std430, binding = 0) buffer BufferObject {
    float kennel_data[KENNEL_SIZE * KENNEL_AMOUNT];
};

vec4 getKennelValue(int start_index);
float relu(float i);
float sigmoid(float i);
float activeValue(int type, float v);

void main(void)
{
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

    int input_shape[3] = int[3](params[0], params[1], params[2]);
    int output_shape[3] = int[3](params[3], params[4], params[5]);
    int active_type = params[6];

    // 获得当前计算器坐标
    vec4 output_vec = vec4(0.0);

    for (int i = 0; i < 4; i++) {
        if (pos.x * 4 + i < KENNEL_AMOUNT) {
        int offset = (pos.x * 4 + i) * KENNEL_SIZE;
            for (int x = 0; x < input_shape[0];x++) {
                for (int y=0; y < input_shape[1]; y++) {
                    vec4 data = imageLoad(input_image, ivec2(x,y));
                    int kennel_start_index= (y * input_shape[0] + x) * 4 + offset;
                    vec4 k_v = getKennelValue(kennel_start_index);
                    output_vec[i] += dot(data, k_v);
                }
            }
            int bias_index = offset + KENNEL_SIZE - 1;
            output_vec[i] += kennel_data[bias_index];
            output_vec[i] = activeValue(active_type, output_vec[i]);
        } else {
            output_vec[i] = 0.0;
        }
    }
    imageStore(output_image, pos.xy, output_vec);
}

vec4 getKennelValue(int start_index) {
    return vec4(kennel_data[start_index], kennel_data[start_index + 1], kennel_data[start_index + 2], kennel_data[start_index + 3]);
}

float relu(float i){
    if (i > 0.0){
        return i;
    } else {
        return 0.0;
    }
}

float sigmoid(float i){
    return 1.0 / (1.0 + exp(-i));
}

float activeValue(int type, float v){
    if (type == 0) {
        return relu(v);
    } else if (type == 1) {
        return sigmoid(v);
    } else if (type == 2){
        return tanh(v);
    } else {
        return v;
    }
}